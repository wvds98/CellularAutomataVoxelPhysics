#define ISAMPERE
#define ISNVIDIA
// default screen resolution
#define SCRWIDTH	1600
#define SCRHEIGHT	1024

// IMPORTANT NOTE ON OPENCL COMPATIBILITY ON OLDER LAPTOPS:
// Without a GPU, a laptop needs at least a 'Broadwell' Intel CPU (5th gen, 2015):
// Intel's OpenCL implementation 'NEO' is not available on older devices.
// Same is true for Vulkan, OpenGL 4.0 and beyond, as well as DX11 and DX12.

// TODO:
// - If we have enough bricks for the full map, each brick pos can point to a fixed brick.
// - An irregular grid may be faster.
// - Add TAA and GI. :)

// settings shared between c/c++ and OpenCL
#define MAPWIDTH	1024	// total world size, x-axis
#define MAPHEIGHT	1024	// total world height
#define MAPDEPTH	1024	// total world size, z-axis
#define BRICKDIM	8		// brick dimensions
#define BDIMLOG2	3		// must be log2(BRICKDIM)
#define MAXCOMMITS	8192	// maximum number of bricks that can be committed per frame
#if 0
// 8-bit voxels: RGB332
#define VOXEL8
#define PAYLOAD unsigned char
#define PAYLOADSIZE	1
#else
// 16-bit voxels: MRGB4444, where M=material index
#define VOXEL16
#define PAYLOAD unsigned short
#define PAYLOADSIZE 2
#endif

// renderer performance setting: set to 0 for slower devices, up to 8 for fast GPUs
#define GIRAYS		6

// Panini projection, http://tksharpless.net/vedutismo/Pannini/panini.pdf via https://www.shadertoy.com/view/Wt3fzB
#define PANINI		0	// 0 to disable, 1 to enable

// TAA, as in https://www.shadertoy.com/view/3sfBWs
#define TAA			1	// 0 to disable, 1 to enable

// MSAA
#define AA_SAMPLES	1	// 1 to disable, 2..4 to enable. Note: will be squared.

// some useful color names
#ifdef VOXEL8
#define BLACK		(1<<5)	// actually: dark red; black itself is transparent
#define GREEN		(7<<2)
#define BLUE		3
#define RED			(7<<5)
#define YELLOW		(RED+GREEN)
#define WHITE		(255)
#define GREY		((3<<5)+(3<<2)+1)
#define ORANGE		((7<<5)+(5<<2))
#define LIGHTBLUE	(3+(4<<2)+(4<<5))
#define BROWN		((3<<5)+(1<<2))
#define LIGHTRED	(7<<5)+(2<<2)+1
#else
#define BLACK		0x001	// actually: dark blue; black itself is transparent
#define GREEN		0x0F0
#define BLUE		0x00F
#define RED			0xF00
#define YELLOW		0xFF0
#define WHITE		0xFFF
#define GREY		0x777
#define ORANGE		0xF70
#define LIGHTBLUE	0x77F
#define BROWN		0x720
#define LIGHTRED	0xF55
#endif

// renderer
struct RenderParams
{
	float2 oneOverRes;
	float3 E, p0, p1, p2;
	uint R0, frame;
	uint skyWidth, skyHeight;
	float4 skyLight[6];
	float skyLightScale, dummy1, dummy2, dummy3;
	// reprojection data
	float4 Nleft, Nright, Ntop, Nbottom;
	float4 prevRight, prevDown;
	float4 prevP0, prevP1, prevP2, prevP3;
};

// lighting for 6 normals for sky15.hdr
#define NX0			0.550f, 0.497f, 0.428f		// N = (-1, 0, 0)
#define NX1			0.399f, 0.352f, 0.299f		// N = ( 1, 0, 0)
#define NY0			0.470f, 0.428f, 0.373f		// N = ( 0,-1, 0)
#define NY1			0.370f, 0.346f, 0.312f		// N = ( 0, 1, 0)
#define NZ0			0.245f, 0.176f, 0.108f		// N = ( 0, 0,-1)
#define NZ1			0.499f, 0.542f, 0.564f		// N = ( 0, 0, 1)

// derived
#define GRIDWIDTH	(MAPWIDTH / BRICKDIM)
#define GRIDHEIGHT	(MAPHEIGHT / BRICKDIM)
#define GRIDDEPTH	(MAPDEPTH / BRICKDIM)
#define GRIDSIZE	(GRIDWIDTH * GRIDHEIGHT * GRIDWIDTH)
#define BRICKSIZE	(BRICKDIM * BRICKDIM * BRICKDIM)
#define UBERWIDTH	(GRIDWIDTH / 4)
#define UBERHEIGHT	(GRIDHEIGHT / 4)
#define UBERDEPTH	(GRIDDEPTH / 4)
// note: we reserve 50% of the theoretical peak; a normal scene shouldn't come close to
// using that many unique (non-empty!) bricks.
#define BRICKCOUNT	((((MAPWIDTH / BRICKDIM) * (MAPHEIGHT / BRICKDIM) * (MAPDEPTH / BRICKDIM))) / 1)
#define BRICKCOMMITSIZE	(MAXCOMMITS * BRICKSIZE * PAYLOADSIZE + MAXCOMMITS * 4 /* bytes */)
#define CHUNKCOUNT	4
#define CHUNKSIZE	((BRICKCOUNT * BRICKSIZE * PAYLOADSIZE) / CHUNKCOUNT)

// experimental
#define ONEBRICKBUFFER	1 // use a single (large) brick buffer; set to 0 on low mem devices
#define MORTONBRICKS	0 // store bricks in morton order to improve data locality (slower)

// constants
#define PI			3.14159265358979323846264f
#define INVPI		0.31830988618379067153777f
#define INV2PI		0.15915494309189533576888f
#define TWOPI		6.28318530717958647692528f
#define SQRT_PI_INV	0.56418958355f
#define LARGE_FLOAT	1e34f
// Optimizations / plans:
// 1. Automate finding the optimal workgroup size
// 2. Keep trying with fewer registers
// 3. Try a 1D job and turn it into tiles in the render kernel
// 4. If all threads enter the same brick, this brick can be in local mem
// 5. Create a website with a library of vox files
// 6. Have a nicer benchmark scene: planet with asteroid debris?
// 7. Trace does not respect initial t
// 8. Add occlusion ray query

// DONE:
// - Figure out how to detect 1080/2080/3080/AMD/other
// - Optimize for 2080 and 1080
// - Try some unrolling on the 2nd loop?
// - Optimize the world: combine 8x8x8 solid voxels
// - Improve readme.md
// - Add UI to obj2vox


// internal stuff
#define OFFS_X		((bits >> 5) & 1)			// extract grid plane offset over x (0 or 1)
#define OFFS_Y		((bits >> 13) & 1)			// extract grid plane offset over y (0 or 1)
#define OFFS_Z		(bits >> 21)				// extract grid plane offset over z (0 or 1)
#define DIR_X		((bits & 3) - 1)			// ray dir over x (-1 or 1)
#define DIR_Y		(((bits >> 8) & 3) - 1)		// ray dir over y (-1 or 1)
#define DIR_Z		(((bits >> 16) & 3) - 1)	// ray dir over z (-1 or 1)
#define EPS			1e-8
#define BMSK		(BRICKDIM - 1)
#define BDIM2		(BRICKDIM * BRICKDIM)
#define BPMX		(MAPWIDTH - BRICKDIM)
#define BPMY		(MAPHEIGHT - BRICKDIM)
#define BPMZ		(MAPDEPTH - BRICKDIM)
#define TOPMASK3	(((1023 - BMSK) << 20) + ((1023 - BMSK) << 10) + (1023 - BMSK))
#define UBERMASK3	((1020 << 20) + (1020 << 10) + 1020)

// fix ray directions that are too close to 0
float4 FixZeroDeltas( float4 V )
{
	if (fabs( V.x ) < EPS) V.x = V.x < 0 ? -EPS : EPS;
	if (fabs( V.y ) < EPS) V.y = V.y < 0 ? -EPS : EPS;
	if (fabs( V.z ) < EPS) V.z = V.z < 0 ? -EPS : EPS;
	return V;
}

#if ONEBRICKBUFFER == 1

//(v && (   (((v >> 8) & 15) * (1.0f / 15.0f)) < 0.05f)) make certain color invisible.
//&& v != RED
#define BRICKSTEP(exitLabel)															\
	v = o + (p >> 20) + ((p >> 7) & (BMSK * BRICKDIM)) + (p & BMSK) * BDIM2;            \
	v = brick0[v]; if (v && v != RED) { *dist = t + to, * side = last; return v; }				    \
	t = min( tm.x, min( tm.y, tm.z ) ), last = 0;										\
	if (t == tm.x) tm.x += td.x, p += dx;												\
	if (t == tm.y) tm.y += td.y, p += dy, last = 1;										\
	if (t == tm.z) tm.z += td.z, p += dz, last = 2;										\
	if (p & TOPMASK3) goto exitLabel;

#else

#define BRICKSTEP(exitLabel)															\
	v = o + (p >> 20) + ((p >> 7) & (BMSK * BRICKDIM)) + (p & BMSK) * BDIM2;			\
	if (p != lp) page = (__global const PAYLOAD*)bricks[v / (CHUNKSIZE / PAYLOADSIZE)], lp = p;	\
	v = page[v & ((CHUNKSIZE / PAYLOADSIZE) - 1)];										\
	if (v) { *dist = t + to, * side = last; return v; }									\
	t = min( tm.x, min( tm.y, tm.z ) ), last = 0;										\
	if (t == tm.x) tm.x += td.x, p += dx;												\
	if (t == tm.y) tm.y += td.y, p += dy, last = 1;										\
	if (t == tm.z) tm.z += td.z, p += dz, last = 2;										\
	if (p & TOPMASK3) goto exitLabel;

#endif

#define GRIDSTEP(exitX)																			\
	if (!--steps) break;																		\
	if (o & 1)																                    \
	{																							\
		const float4 tm_ = tm;																	\
		const uint4 p4 = convert_uint4( A + V * (t *= 8) );										\
		uint v, p = (clamp( p4.x, tp >> 17, (tp >> 17) + 7 ) << 20) +							\
			(clamp( p4.y, (tp >> 7) & 1023, ((tp >> 7) & 1023) + 7 ) << 10) +					\
			clamp( p4.z, (tp << 3) & 1023, ((tp << 3) & 1023) + 7 ), lp = ~1;					\
		tm = (convert_float4( (uint4)((p >> 20) + OFFS_X, ((p >> 10) & 1023) +					\
			OFFS_Y, (p & 1023) + OFFS_Z, 0) ) - A) * rV;										\
		p &= 7 + (7 << 10) + (7 << 20), o = --o << 8;											\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
		BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX ); BRICKSTEP( exitX );			\
	exitX: tm = tm_;																			\
	}																							\
	t = min( tm.x, min( tm.y, tm.z ) ), last = 0;												\
	if (t == tm.x) tm.x += td.x, tp += dx;														\
	if (t == tm.y) tm.y += td.y, tp += dy, last = 1;											\
	if (t == tm.z) tm.z += td.z, tp += dz, last = 2;											\
	if ((tp & UBERMASK3) - tq) break;															\
	o = read_imageui( grid, (int4)(tp >> 20, tp & 127, (tp >> 10) & 127, 0) ).x;

// mighty two-level grid traversal
uint TraceRay( float4 A, const float4 B, float* dist, uint* side, __read_only image3d_t grid,
	__global const unsigned char* uberGrid,
	__global const PAYLOAD* brick0,
#if ONEBRICKBUFFER == 0
	__global const PAYLOAD* brick1,
	__global const PAYLOAD* brick2,
	__global const PAYLOAD* brick3,
#endif
	int steps
)
{
#if ONEBRICKBUFFER == 0
	__global const PAYLOAD* bricks[4] = { brick0, brick1, brick2, brick3 };
#endif
	const float4 V = FixZeroDeltas( B ), rV = (float4)(1.0 / V.x, 1.0 / V.y, 1.0 / V.z, 1);
	float to = 0; // distance to travel to get into grid
	const int bits = select( 4, 34, V.x > 0 ) + select( 3072, 10752, V.y > 0 ) + select( 1310720, 3276800, V.z > 0 ); // magic
	uint last = 0, dx = DIR_X << 20, dy = DIR_Y << 10, dz = DIR_Z;
	if (A.x < 0 || A.y < 0 || A.z < 0 || A.x > MAPWIDTH || A.y > MAPHEIGHT || A.z > MAPDEPTH)
	{
		// use slab test to clip ray origin against scene AABB
		const float tx1 = -A.x * rV.x, tx2 = (MAPWIDTH - A.x) * rV.x;
		float tmin = min( tx1, tx2 ), tmax = max( tx1, tx2 );
		const float ty1 = -A.y * rV.y, ty2 = (MAPHEIGHT - A.y) * rV.y;
		tmin = max( tmin, min( ty1, ty2 ) ), tmax = min( tmax, max( ty1, ty2 ) );
		const float tz1 = -A.z * rV.z, tz2 = (MAPDEPTH - A.z) * rV.z;
		tmin = max( tmin, min( tz1, tz2 ) ), tmax = min( tmax, max( tz1, tz2 ) );
		if (tmax < tmin || tmax <= 0) return 0; // ray misses scene 
		A += tmin * V, to = tmin; // new ray entry point
		// update 'last', for correct handling of hits on the border of the map
		if (A.y < 0.01f || A.y >( MAPHEIGHT - 1.01f )) last = 1;
		if (A.z < 0.01f || A.z >( MAPDEPTH - 1.01f )) last = 2;
	}
	uint up = (clamp( (uint)A.x >> 5, 0u, 31u ) << 20) + (clamp( (uint)A.y >> 5, 0u, 31u ) << 10) +
		clamp( (uint)A.z >> 5, 0u, 31u );
	float4 tm = ((float4)((up >> 20) + OFFS_X, ((up >> 10) & 31) + OFFS_Y, (up & 31) + OFFS_Z, 0) - A * 0.03125f) * rV;
	float t = 0;
	const float4 td = (float4)(DIR_X, DIR_Y, DIR_Z, 0) * rV;
	uint o = uberGrid[(up >> 20) + ((up & 31) << 5) + (((up >> 10) & 31) << 10)];
	while (1)
	{
		if ((steps -= 4) <= 0) break;
		if (o)
		{
			// backup ubergrid traversal state
			const float4 tm_ = tm;
			// intialize topgrid traversal
			const uint4 p4 = convert_uint4( 0.125f * A + V * (t *= 4) );
			uint tp = (clamp( p4.x, up >> 18, (up >> 18) + 3 ) << 20) +
				(clamp( p4.y, (up >> 8) & 1023, ((up >> 8) & 1023) + 3 ) << 10) +
				clamp( p4.z, (up << 2) & 1023, ((up << 2) & 1023) + 3 ), tq = tp & UBERMASK3;
			tm = (convert_float4( (uint4)((tp >> 20) + OFFS_X, ((tp >> 10) & 127) + OFFS_Y,
				(tp & 127) + OFFS_Z, 0) ) - A * 0.125f) * rV;
			o = read_imageui( grid, (int4)(tp >> 20, tp & 127, (tp >> 10) & 127, 0) ).x;
			while (1)
			{
			#if ONEBRICKBUFFER == 0
				__global const PAYLOAD* page;
			#endif
			#ifdef ISAMPERE
				GRIDSTEP(exit1); GRIDSTEP(exit2); // Ampere has massive L1I$;
				GRIDSTEP(exit3); GRIDSTEP(exit4); // unroll 4x for best performance.
			#else
				GRIDSTEP(exit1); // Turing and older have smaller L1I$, don't unroll
			#endif
			}
			// restore ubergrid traversal state
			tm = tm_;
		}
		t = min( tm.x, min( tm.y, tm.z ) ), last = 0;
		if (t == tm.x) tm.x += td.x, up += dx;
		if (t == tm.y) tm.y += td.y, up += dy, last = 1;
		if (t == tm.z) tm.z += td.z, up += dz, last = 2;
		if (up & 0xfe0f83e0) break;
		o = uberGrid[(up >> 20) + ((up & 31) << 5) + (((up >> 10) & 31) << 10)];
	}
	return 0U;
}

void TraceRayToVoid( float4 A, float4 V, float* dist, float3* N, __read_only image3d_t grid,
#if ONEBRICKBUFFER == 1
	__global const PAYLOAD* brick,
#else
	__global const PAYLOAD* brick0, __global const PAYLOAD* brick1,
	__global const PAYLOAD* brick2, __global const PAYLOAD* brick3,
#endif
	__global const unsigned char* uber
)
{
#if 0 // TODO
#if ONEBRICKBUFFER == 0
	__global const PAYLOAD* bricks[4] = { brick0, brick1, brick2, brick3 };
#endif
	V = FixZeroDeltas( V );
	const float4 rV = (float4)(1.0 / V.x, 1.0 / V.y, 1.0 / V.z, 1);
	if (A.x < 0 || A.y < 0 || A.z < 0 || A.x > MAPWIDTH || A.y > MAPHEIGHT || A.z > MAPDEPTH)
	{
		*dist = 0; // we start outside the grid, and thus in empty space: don't do that
		return;
	}
	uint tp = (clamp( (uint)A.x >> 3, 0u, 127u ) << 20) + (clamp( (uint)A.y >> 3, 0u, 127u ) << 10) +
		clamp( (uint)A.z >> 3, 0u, 127u );
	const int bits = select( 4, 34, V.x > 0 ) + select( 3072, 10752, V.y > 0 ) + select( 1310720, 3276800, V.z > 0 ); // magic
	float4 tm = ((float4)(((tp >> 20) & 127) + ((bits >> 5) & 1), ((tp >> 10) & 127) + ((bits >> 13) & 1),
		(tp & 127) + ((bits >> 21) & 1), 0) - A * 0.125f) * rV;
	float4 td = (float4)(DIR_X, DIR_Y, DIR_Z, 0) * rV;
	float t = 0;
	uint last = 0;
	do
	{
		// fetch brick from top grid
		uint o = read_imageui( grid, (int4)(tp >> 20, tp & 127, (tp >> 10) & 127, 0) ).x;
		if (o == 0) /* empty brick: done */
		{
			*dist = t * 8.0f;
			*N = -(float3)((last == 0) * DIR_X, (last == 1) * DIR_Y, (last == 2) * DIR_Z);
			return;
		}
		else if ((o & 1) == 1) /* non-empty brick */
		{
			// backup top-grid traversal state
			const float4 tm_ = tm;
			// intialize brick traversal
			tm = A + V * (t *= 8); // abusing tm for I to save registers
			uint p = (clamp( (uint)tm.x, tp >> 17, (tp >> 17) + 7 ) << 20) +
				(clamp( (uint)tm.y, (tp >> 7) & 1023, ((tp >> 7) & 1023) + 7 ) << 10) +
				clamp( (uint)tm.z, (tp << 3) & 1023, ((tp << 3) & 1023) + 7 ), lp = ~1;
			tm = ((float4)((p >> 20) + OFFS_X, ((p >> 10) & 1023) + OFFS_Y, (p & 1023) + OFFS_Z, 0) - A) * rV;
			p &= 7 + (7 << 10) + (7 << 20), o = (o >> 1) * BRICKSIZE;
			__global const PAYLOAD* page;
			do // traverse brick
			{
				o += (p >> 20) + ((p >> 7) & (BMSK * BRICKDIM)) + (p & BMSK) * BDIM2;
			#if ONEBRICKBUFFER == 1
				if (!((__global const PAYLOAD*)brick0)[o])
				#else
				if (p != lp) page = (__global const PAYLOAD*)bricks[o / (CHUNKSIZE / PAYLOADSIZE)], lp = p;
				if (!page[o & ((CHUNKSIZE / PAYLOADSIZE) - 1)])
				#endif
				{
					*dist = t;
					*N = -(float3)((last == 0) * DIR_X, (last == 1) * DIR_Y, (last == 2) * DIR_Z);
					return;
				}
				t = min( tm.x, min( tm.y, tm.z ) );
				if (t == tm.x) tm.x += td.x, p += DIR_X << 20, last = 0;
				else if (t == tm.y) tm.y += td.y, p += ((bits << 2) & 3072) - 1024, last = 1;
				else if (t == tm.z) tm.z += td.z, p += DIR_Z, last = 2;
			} while (!(p & TOPMASK3));
			tm = tm_; // restore top-grid traversal state
		}
		t = min( tm.x, min( tm.y, tm.z ) );
		if (t == tm.x) tm.x += td.x, tp += DIR_X << 20, last = 0;
		else if (t == tm.y) tm.y += td.y, tp += DIR_Y << 10, last = 1;
		else if (t == tm.z) tm.z += td.z, tp += DIR_Z, last = 2;
	} while (!(tp & 0xf80e0380));
#endif
}
float SphericalTheta( const float3 v )
{
	return acos( clamp( v.z, -1.f, 1.f ) );
}

float SphericalPhi( const float3 v )
{
	const float p = atan2( v.y, v.x );
	return (p < 0) ? (p + 2 * PI) : p;
}

uint WangHash( uint s ) { s = (s ^ 61) ^ (s >> 16), s *= 9, s = s ^ (s >> 4), s *= 0x27d4eb2d, s = s ^ (s >> 15); return s; }
uint RandomInt( uint* s ) { *s ^= *s << 13, * s ^= *s >> 17, * s ^= *s << 5; return *s; }
float RandomFloat( uint* s ) { return RandomInt( s ) * 2.3283064365387e-10f; }

float3 DiffuseReflectionCosWeighted( const float r0, const float r1, const float3 N )
{
	const float3 T = normalize( cross( N, fabs( N.y ) > 0.99f ? (float3)(1, 0, 0) : (float3)(0, 1, 0) ) );
	const float3 B = cross( T, N );
	const float term1 = TWOPI * r0, term2 = sqrt( 1 - r1 );
	float c, s = sincos( term1, &c );
	return (c * term2 * T) + (s * term2) * B + sqrt( r1 ) * N;
}

float blueNoiseSampler( const __global uint* blueNoise, int x, int y, int sampleIndex, int sampleDimension )
{
	// Adapated from E. Heitz. Arguments:
	// sampleIndex: 0..255
	// sampleDimension: 0..255
	x &= 127, y &= 127, sampleIndex &= 255, sampleDimension &= 255;
	// xor index based on optimized ranking
	int rankedSampleIndex = (sampleIndex ^ blueNoise[sampleDimension + (x + y * 128) * 8 + 65536 * 3]) & 255;
	// fetch value in sequence
	int value = blueNoise[sampleDimension + rankedSampleIndex * 256];
	// if the dimension is optimized, xor sequence value based on optimized scrambling
	value ^= blueNoise[(sampleDimension & 7) + (x + y * 128) * 8 + 65536];
	// convert to float and return
	float retVal = (0.5f + value) * (1.0f / 256.0f) /* + noiseShift (see LH2) */;
	if (retVal >= 1) retVal -= 1;
	return retVal;
}

// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1] -  via https://www.shadertoy.com/view/tt3BRS
float3 PaniniProjection( float2 tc, const float fov, const float d )
{
	const float d2 = d * d;
	{
		const float fo = PI * 0.5f - fov * 0.5f;
		const float f = cos( fo ) / sin( fo ) * 2.0f;
		const float f2 = f * f;
		const float b = (native_sqrt( max( 0.f, (d + d2) * (d + d2) * (f2 + f2 * f2) ) ) - (d * f + f)) / (d2 + d2 * f2 - 1);
		tc *= b;
	}
	const float h = tc.x, v = tc.y, h2 = h * h;
	const float k = h2 / ((d + 1) * (d + 1)), k2 = k * k;
	const float discr = max( 0.f, k2 * d2 - (k + 1) * (k * d2 - 1) );
	const float cosPhi = (-k * d + native_sqrt( discr )) / (k + 1.f);
	const float S = (d + 1) / (d + cosPhi), tanTheta = v / S;
	float sinPhi = native_sqrt( max( 0.f, 1 - cosPhi * cosPhi ) );
	if (tc.x < 0.0) sinPhi *= -1;
	const float s = native_rsqrt( 1 + tanTheta * tanTheta );
	return (float3)(sinPhi, tanTheta, cosPhi) * s;
}

__constant float halton[32] = { 
	0, 0, 0.5f, 0.333333f, 0, 0.6666666f, 0.75f, 0.111111111f, 0, 0.44444444f, 
	0.5f, 0.7777777f, 0.25f, 0.222222222f, 0.75f, 0.55555555f, 0, 0.88888888f, 
	0.5f, 0.03703703f, 0.25f, 0.37037037f, 0.75f, 0.70370370f, 0.125f, 0.148148148f,
	0.625f, 0.481481481f, 0.375f, 0.814814814f, 0.875f, 0.259259259f 
};

// produce a camera ray direction for a position in screen space
float3 GenerateCameraRay( const float2 pixelPos, __constant struct RenderParams* params )
{
#if TAA
	const uint px = (uint)pixelPos.x;
	const uint py = (uint)pixelPos.y;
	const uint h = (params->frame + (px & 3) + 4 * (py & 3)) & 15;
	const float2 uv = (float2)(
		(pixelPos.x + halton[h * 2 + 0]) * params->oneOverRes.x, 
		(pixelPos.y + halton[h * 2 + 1]) * params->oneOverRes.y
	);
#else
	const float2 uv = (float2)(
		pixelPos.x * params->oneOverRes.x, 
		pixelPos.y * params->oneOverRes.y
	);
#endif
#if PANINI
	const float3 V = PaniniProjection( (float2)(uv.x * 2 - 1, (uv.y * 2 - 1) * ((float)SCRHEIGHT / SCRWIDTH)), PI / 5, 0.15f );
	// multiply by improvised camera matrix
	return V.z * normalize( (params->p1 + params->p2) * 0.5f - params->E ) +
		V.x * normalize( params->p1 - params->p0 ) + V.y * normalize( params->p2 - params->p0 );
#else
	const float3 P = params->p0 + (params->p1 - params->p0) * uv.x + (params->p2 - params->p0) * uv.y;
	return normalize( P - params->E );
#endif
}

// sample the HDR sky dome texture (bilinear)
float3 SampleSky( const float3 T, __global float4* sky, uint w, uint h )
{
	const float u = w * SphericalPhi( T ) * INV2PI - 0.5f;
	const float v = h * SphericalTheta( T ) * INVPI - 0.5f;
	const float fu = u - floor( u ), fv = v - floor( v );
	const int iu = (int)u, iv = (int)v;
	const uint idx1 = (iu + iv * w) % (w * h);
	const uint idx2 = (iu + 1 + iv * w) % (w * h);
	const uint idx3 = (iu + (iv + 1) * w) % (w * h);
	const uint idx4 = (iu + 1 + (iv + 1) * w) % (w * h);
	const float4 s =
		sky[idx1] * (1 - fu) * (1 - fv) + sky[idx2] * fu * (1 - fv) +
		sky[idx3] * (1 - fu) * fv + sky[idx4] * fu * fv;
	return s.xyz;
}

// convert a voxel color to floating point rgb
float3 ToFloatRGB( const uint v )
{
#if PAYLOADSIZE == 1
	return (float3)((v >> 5) * (1.0f / 7.0f), ((v >> 2) & 7) * (1.0f / 7.0f), (v & 3) * (1.0f / 3.0f));
#else
	return (float3)(((v >> 8) & 15) * (1.0f / 15.0f), ((v >> 4) & 15) * (1.0f / 15.0f), (v & 15) * (1.0f / 15.0f));
#endif
}

// ACES filmic tonemapping, via https://www.shadertoy.com/view/3sfBWs
float3 ACESFilm( const float3 x )
{
	float a = 2.51f, b = 0.03f, c = 2.43f, d = 0.59f, e = 0.14f;
	return clamp( (x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f );
}

// Reinhard2 tonemapping, via https://www.shadertoy.com/view/WdjSW3
float3 Reinhard2( const float3 x )
{
	const float3 L_white = (float3)4.0f;
	return (x * (1.0f + x / (L_white * L_white))) / (1.0f + x);
}

// https://twitter.com/jimhejl/status/633777619998130176
float3 ToneMapFilmic_Hejl2015(const float3 hdr, float whitePt) 
{
    float4 vh = (float4)(hdr, whitePt);
    float4 va = 1.425f * vh + 0.05f;
    float4 vf = (vh * va + 0.004f) / (vh * (va + 0.55f) + 0.0491f) - 0.0821f;
    return vf.xyz / vf.www;
}

// Linear to SRGB, also via https://www.shadertoy.com/view/3sfBWs
float3 LessThan( const float3 f, float value )
{
	return (float3)(
		(f.x < value) ? 1.0f : 0.0f,
		(f.y < value) ? 1.0f : 0.0f,
		(f.z < value) ? 1.0f : 0.0f);
}
float3 LinearToSRGB( const float3 rgb )
{
#if 0
	return sqrt( rgb );
#else
	const float3 _rgb = clamp( rgb, 0.0f, 1.0f );
	return mix( pow( _rgb * 1.055f, (float3)(1.f / 2.4f) ) - 0.055f,
		_rgb * 12.92f, LessThan( _rgb, 0.0031308f )
	);
#endif
}

// conversions between RGB and YCoCG for TAA
float3 RGBToYCoCg( const float3 RGB )
{
	const float3 rgb = min( (float3)( 4 ), RGB ); // clamp helps AA for strong HDR
	const float Y = dot( rgb, (float3)( 1, 2, 1 ) ) * 0.25f;
	const float Co = dot( rgb, (float3)( 2, 0, -2 ) ) * 0.25f + (0.5f * 256.0f / 255.0f);
	const float Cg = dot( rgb, (float3)( -1, 2, -1 ) ) * 0.25f + (0.5f * 256.0f / 255.0f);
	return (float3)( Y, Co, Cg );
}

float3 YCoCgToRGB( const float3 YCoCg )
{
	const float Y = YCoCg.x;
	const float Co = YCoCg.y - (0.5f * 256.0f / 255.0f);
	const float Cg = YCoCg.z - (0.5f * 256.0f / 255.0f);
	return (float3)( Y + Co - Cg, Y + Cg, Y - Co - Cg );
}

// sample a color buffer with bilinear interpolation
float3 bilerpSample( const __global float4* buffer, const float u, const float v )
{
	// do a bilerp fetch at u_prev, v_prev
	float fu = u - floor( u ), fv = v - floor( v );
	int iu = (int)u, iv = (int)v;
	if (iu == 0 || iv == 0 || iu >= SCRWIDTH - 1 || iv >= SCRHEIGHT - 1) return (float3)0;
	int iu0 = clamp( iu, 0, SCRWIDTH - 1 ), iu1 = clamp( iu + 1, 0, SCRWIDTH - 1 );
	int iv0 = clamp( iv, 0, SCRHEIGHT - 1 ), iv1 = clamp( iv + 1, 0, SCRHEIGHT - 1 );
	float4 p0 = (1 - fu) * (1 - fv) * buffer[iu0 + iv0 * SCRWIDTH];
	float4 p1 = fu * (1 - fv) * buffer[iu1 + iv0 * SCRWIDTH];
	float4 p2 = (1 - fu) * fv * buffer[iu0 + iv1 * SCRWIDTH];
	float4 p3 = fu * fv * buffer[iu1 + iv1 * SCRWIDTH];
	return (p0 + p1 + p2 + p3).xyz;
}

// inefficient morton code for bricks (3 bit per axis, x / y / z)
int Morton3Bit( const int x, const int y, const int z )
{	
	return (x & 1) + 2 * (y & 1) + 4 * (z & 1) +
		4 * (x & 2) + 8 * (y & 2) + 16 * (z & 2) +
		16 * (x & 4) + 32 * (y & 4) + 64 * (z & 4);
}
int Morton3( const int xyz )
{	
	return (xyz & 1) + ((xyz & 8) >> 2) + ((xyz & 64) >> 4) +
		((xyz & 2) << 2) + (xyz & 16) + ((xyz & 128) >> 2) + 
		((xyz & 4) << 4) + ((xyz & 32) << 2) + (xyz & 256);
}

// building a normal from an axis and a ray direction
float3 VoxelNormal( const uint side, const float3 D )
{
	if (side == 0) return (float3)(D.x > 0 ? -1 : 1, 0, 0 );
	if (side == 1) return (float3)(0, D.y > 0 ? -1 : 1, 0 );
	if (side == 2) return (float3)(0, 0, D.z > 0 ? -1 : 1 );
}

//Required on 6900XT
#pragma OPENCL EXTENSION cl_khr_3d_image_writes : enable

//Sloppy copy for now, make this a proper include
// CAPE - Cellular Automata Physics Engine
#define USECONCURRENCY 0
#define PRESSURE_ITERATIONS 8
#define DEBUG_MODE 1
#define CAPE_BRICKDIM 4
#define CAPE_GRIDWIDTH (MAPWIDTH / CAPE_BRICKDIM + 2)
#define CAPE_GRIDHEIGHT (MAPHEIGHT / CAPE_BRICKDIM + 2)
#define CAPE_GRIDDEPTH (MAPDEPTH / CAPE_BRICKDIM + 2)
#define CAPE_GRIDSIZE (CAPE_GRIDWIDTH * CAPE_GRIDHEIGHT * CAPE_GRIDDEPTH)
#define CAPE_BRICKSIZE (CAPE_BRICKDIM * CAPE_BRICKDIM * CAPE_BRICKDIM)
#define BIX(x, y, z) ((x)+(y) * (CAPE_GRIDWIDTH) + (z) * (CAPE_GRIDHEIGHT) * (CAPE_GRIDDEPTH))
#define MIN_BRICKMASS 0.001f
#define VELOCITY_DAMPENING 0.01f 
#define AL 0.5f //Advection limiter, prevents oscillations
#define INVAL (1.0f/AL) 
#define MINBRICKS 50 //Minimum amount of bricks to reserve in memory
#define UINT32_MAX 0xffffffff

#define EVAPORATION 0.0f //amount of mass to remove per cell per second (helps clean up low mass cells that are not visible.)
#define MINRENDERMASS 0.001f //Dont render voxels below this much mass
#define GRAVITYENABLED 1
#define CELLSIZE 0.10f //In meters, essentially multiplier for gravity
#define timestep 0.01f

//0.333 is maximum 100% save speed, use up to 1.0f for less clamping and faster flowing water (less viscous), but requires that an appropriate
//timestep is selected by the user, or simulation may blow up if local velocity becomes too high and negative mass is created
#define MAXV 0.33f

__kernel void run(){}

inline uint GetBrickIDX(const uint x, const uint y, const uint z)
{
	// calculate brick location in top-level grid
	const uint bx = x / CAPE_BRICKDIM;
	const uint by = y / CAPE_BRICKDIM;
	const uint bz = z / CAPE_BRICKDIM;
	if (bx >= CAPE_GRIDWIDTH || by >= CAPE_GRIDHEIGHT || bz >= CAPE_GRIDDEPTH) return UINT32_MAX;
	const uint brickIdx = (bx)+(by) * (CAPE_GRIDWIDTH) + (bz) * (CAPE_GRIDHEIGHT) * (CAPE_GRIDDEPTH);
	return brickIdx;
}

inline float GetData(const uint x, const uint y, const uint z, __global uint* grid, __global float* data)
{
	// obtain brick reference from top-level grid if brick does not exist, return "default" value
	const uint bID = grid[GetBrickIDX(x, y, z)]; 
	if (bID == UINT32_MAX) return 0; 
	__global float* d = data + bID * CAPE_BRICKSIZE;// [bID] ;
	const uint lx = x & (CAPE_BRICKDIM - 1), ly = y & (CAPE_BRICKDIM - 1), lz = z & (CAPE_BRICKDIM - 1);
	return d[lx + ly * CAPE_BRICKDIM + lz * CAPE_BRICKDIM * CAPE_BRICKDIM];
}

inline void SetData(const uint x, const uint y, const uint z, float v, __global uint* grid, __global float* data)
{
    const uint bidx = GetBrickIDX(x, y, z);
	const uint bID = grid[bidx];
	if (bID == UINT32_MAX) return;
	global float* d = data + bID * CAPE_BRICKSIZE;
	const uint lx = x & (CAPE_BRICKDIM - 1), ly = y & (CAPE_BRICKDIM - 1), lz = z & (CAPE_BRICKDIM - 1);
	uint cellIdx = lx + ly * CAPE_BRICKDIM + lz * CAPE_BRICKDIM * CAPE_BRICKDIM;
	d[cellIdx] = v;
}

//Determine change in mass given current velocities
//Assume cells cannot go past maximum density (e.g 1), therefore clamp to 1.0
float MaterialChange(const uint x, const uint y, const uint z, const float vxl, const float vxr, const float vyl, const float vyr, const float vzl, const float vzr,
                     __global uint* grid, __global float* m0_bricks)
{
	float mat   = GetData(x, y, z, grid, m0_bricks);
	float matxl = GetData(x - 1, y, z, grid, m0_bricks); 
	float matyl = GetData(x, y - 1, z, grid, m0_bricks); 
	float matzl = GetData(x, y, z - 1, grid, m0_bricks);
	float matxr = GetData(x + 1, y, z, grid, m0_bricks); 
	float matyr = GetData(x, y + 1, z, grid, m0_bricks); 
	float matzr = GetData(x, y, z + 1, grid, m0_bricks);

	float dxl = vxl < 0 ? vxl * min(1.0f, mat) : vxl * min(1.0f, matxl);
	float dyl = vyl < 0 ? vyl * min(1.0f, mat) : vyl * min(1.0f, matyl);
	float dzl = vzl < 0 ? vzl * min(1.0f, mat) : vzl * min(1.0f, matzl);
	float dxr = vxr < 0 ? -vxr * min(1.0f, matxr) : -vxr * min(1.0f, mat);
	float dyr = vyr < 0 ? -vyr * min(1.0f, matyr) : -vyr * min(1.0f, mat);
	float dzr = vzr < 0 ? -vzr * min(1.0f, matzr) : -vzr * min(1.0f, mat);
	return dxl + dyl + dzl + dxr + dyr + dzr;
}

__kernel void calculateDivergence(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* m_bricks, __global float* m0_bricks, __global float* vx0_bricks, __global float* vy0_bricks,
                  __global float* vz0_bricks, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* p0_bricks)
{
	int id = get_global_id(0);

	//Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	SetData(x, y, z, 0, grid, m_bricks);
	SetData(x, y, z, 0, grid, p0_bricks);
	float vxl = GetData(x, y, z, grid, vx0_bricks) * AL;
	float vyl = GetData(x, y, z, grid, vy0_bricks) * AL;
	float vzl = GetData(x, y, z, grid, vz0_bricks) * AL;
	float vxr = GetData(x + 1, y, z, grid, vx0_bricks) * AL;
	float vyr = GetData(x, y + 1, z, grid, vy0_bricks) * AL;
	float vzr = GetData(x, y, z + 1, grid, vz0_bricks) * AL;

	float mc = MaterialChange(x, y, z, vxl, vxr, vyl, vyr, vzl, vzr, grid, m0_bricks); //divergence = amount of mass over 1 and under 0
	float div = (GetData(x, y, z, grid, m0_bricks) + mc - 1.0f) * 2.0f; //new mass, premultiply by 2 to prevent gradient division 
	//Store in temporarily unused material buffer
	SetData(x, y, z, div, grid, m_bricks);
}

#define BMSK (BRICKDIM - 1)
#define BRICKDIM 8
#define BRICKSIZE (BRICKDIM * BRICKDIM * BRICKDIM)
#define BDIM2 (BRICKDIM * BRICKDIM)
#define GRIDWIDTH 128
#define GRIDHEIGHT 128
#define GRIDDEPTH 128
uint worldGet(const uint x, const uint y, const uint z, __read_only image3d_t grid, __global unsigned short* brick)
{
	// calculate brick location in top-level grid
	const uint bx = (x / BRICKDIM) & (GRIDWIDTH - 1);
	const uint by = (y / BRICKDIM) & (GRIDHEIGHT - 1);
	const uint bz = (z / BRICKDIM) & (GRIDDEPTH - 1);
	const uint cellIdx = bx + bz * GRIDWIDTH + by * GRIDWIDTH * GRIDDEPTH;
	const uint g = read_imageui(grid, (int4)(bx, bz, by, 0)).x;
	if ((g & 1) == 0 /* this is currently an empty cell */) return 0;
	// calculate the position of the voxel inside the brick
	const uint lx = x & (BRICKDIM - 1), ly = y & (BRICKDIM - 1), lz = z & (BRICKDIM - 1);
	return brick[(g >> 1) * BRICKSIZE + lx + ly * BRICKDIM + lz * BRICKDIM * BRICKDIM];
}

void worldSet(const uint x, const uint y, const uint z, __write_only image3d_t grid, __global unsigned short* brick, __global uint* zeroes,  uint v)
{
	// calculate brick location in top-level grid
	const uint bx = (x / BRICKDIM) & (GRIDWIDTH - 1);
	const uint by = (y / BRICKDIM) & (GRIDHEIGHT - 1);
	const uint bz = (z / BRICKDIM) & (GRIDDEPTH - 1);
	const uint cellIdx = bx + bz * GRIDWIDTH + by * GRIDWIDTH * GRIDDEPTH; //index of brick

	// calculate the position of the voxel inside the brick
	const uint lx = x & (BRICKDIM - 1), ly = y & (BRICKDIM - 1), lz = z & (BRICKDIM - 1);
	uint voxelIdx = cellIdx * BRICKSIZE + lx + ly * BRICKDIM + lz * BRICKDIM * BRICKDIM;
	const uint cv = brick[voxelIdx]; //original value

	atomic_add(zeroes + cellIdx, (cv != 0 && v == 0) - (cv == 0 && v != 0)); //Apply the change in zeroes
	write_imageui(grid, (int4)(bx, bz, by, 0), (uint4)((cellIdx << 1) | (zeroes[cellIdx] < BRICKSIZE), 0,0,0)); //Update zero status
	brick[voxelIdx] = v;
}

bool IsCellStatic(const uint x, const uint y, const uint z, __global uint* grid, __global char* brick_static, __global float* m0_bricks, __read_only image3d_t worldGrid, __global const unsigned short* worldBricks)
{
	// calculate brick location in top-level grid
	uint brickIDX = GetBrickIDX(x, y, z);
	uint brick_addr = grid[brickIDX];
	if (brick_addr == UINT32_MAX)
		return true;

	bool static_brick = brick_static[brick_addr];
	float m = GetData(x, y, z, grid, m0_bricks);

	//Get world voxel
	bool ws = worldGet(x - CAPE_BRICKDIM,y - CAPE_BRICKDIM,z - CAPE_BRICKDIM, worldGrid, worldBricks) != 0;

	return (m == 0 && ws) || static_brick; 
}

__kernel void solvePressure(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* m_bricks, __global float* m0_bricks, __global float* p_bricks, __global float* p0_bricks, __read_only image3d_t worldGrid, __global const unsigned short* worldBricks)
{
	int id = get_global_id(0);

	//Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	float div = GetData(x, y, z, grid, m_bricks);
	float nbp = 0;
	float k = 0;
	nbp += max(0.0f, GetData(x + 1, y, z, grid, p0_bricks));
	nbp += max(0.0f, GetData(x - 1, y, z, grid, p0_bricks));
	nbp += max(0.0f, GetData(x, y + 1, z, grid, p0_bricks));
	nbp += max(0.0f, GetData(x, y - 1, z, grid, p0_bricks));
	nbp += max(0.0f, GetData(x, y, z + 1, grid, p0_bricks));
	nbp += max(0.0f, GetData(x, y, z - 1, grid, p0_bricks));

	k += (IsCellStatic(x + 1, y, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);
	k += (IsCellStatic(x - 1, y, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);
	k += (IsCellStatic(x, y + 1, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);
	k += (IsCellStatic(x, y - 1, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);
	k += (IsCellStatic(x, y, z + 1, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);
	k += (IsCellStatic(x, y, z - 1, grid, brick_static, m0_bricks, worldGrid, worldBricks) == 0);

	float np = (div + nbp) / k;
	SetData(x, y, z, np, grid, p_bricks);
}

__kernel void pressureGradient(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* m_bricks, __global float* m0_bricks, __global float* vx0_bricks, __global float* vy0_bricks,
                  __global float* vz0_bricks, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* p0_bricks, __read_only image3d_t worldGrid, __global const unsigned short* worldBricks)
{
	int id = get_global_id(0);

    //Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	//solid cells do not experience pressure 
	if (IsCellStatic(x, y, z, grid, brick_static, m0_bricks, worldGrid, worldBricks))
		return;

	float cellPressure = max(0.0f, GetData(x,y,z, grid, p0_bricks));

	//No pressure gradient to solid cells, therefore simply set to equal pressure
	float ovxl = GetData(x, y, z, grid, vx0_bricks);
	float ovyl = GetData(x, y, z, grid, vy0_bricks);
	float ovzl = GetData(x, y, z, grid, vz0_bricks);
	float leftPressure = max(0.0f, IsCellStatic(x - 1, y, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) ? cellPressure : GetData(x - 1, y, z, grid, p0_bricks));
	float botPressure = max(0.0f, IsCellStatic(x, y - 1, z, grid, brick_static, m0_bricks, worldGrid, worldBricks) ? cellPressure : GetData(x, y - 1,z, grid, p0_bricks));
	float backPressure = max(0.0f, IsCellStatic(x, y, z - 1, grid, brick_static, m0_bricks, worldGrid, worldBricks) ? cellPressure : GetData(x, y, z - 1, grid, p0_bricks));

	//Determine acceleration from pressure gradient
	//Since we are also finalising the velocity for the current update here, we want to dampen
	//the original remaining velocity and clamp the velocity so we do not exceed the maximum here
	float dampen = 1 - VELOCITY_DAMPENING * timestep;
	float vxa = leftPressure - cellPressure;
	float vya = botPressure - cellPressure;
	float vza = backPressure - cellPressure;
	float vxl = ovxl * dampen + vxa;
	float vyl = ovyl * dampen + vya;
	float vzl = ovzl * dampen + vza;
	SetData(x, y, z, clamp(vxl, -MAXV, MAXV), grid, vx_bricks);
	SetData(x, y, z, clamp(vyl, -MAXV, MAXV), grid, vy_bricks);
	SetData(x, y, z, clamp(vzl, -MAXV, MAXV), grid, vz_bricks);
}

__kernel void materialAdvection(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* brick_m, __global float* m_bricks, __global float* m0_bricks, __global float* vx0_bricks, __global float* vy0_bricks,
                                __global float* vz0_bricks, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* p0_bricks, __read_only image3d_t worldGrid, __global const unsigned short* worldBricks)
{
	int id = get_global_id(0);

    //Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	float vxl = GetData(x, y, z, grid, vx0_bricks) * AL;
	float vyl = GetData(x, y, z, grid, vy0_bricks) * AL;
	float vzl = GetData(x, y, z, grid, vz0_bricks) * AL;
	float vxr = GetData(x + 1, y, z, grid, vx0_bricks) * AL;
	float vyr = GetData(x, y + 1, z, grid, vy0_bricks) * AL;
	float vzr = GetData(x, y, z + 1, grid, vz0_bricks) * AL;

	//node focussed advection
	float mat = GetData(x, y, z, grid, m0_bricks);
	float matxl = GetData(x - 1, y, z, grid, m0_bricks); 
	float matyl = GetData(x, y - 1, z, grid, m0_bricks); 
	float matzl = GetData(x, y, z - 1, grid, m0_bricks); 
	float matxr = GetData(x + 1, y, z, grid, m0_bricks); 
	float matyr = GetData(x, y + 1, z, grid, m0_bricks); 
	float matzr = GetData(x, y, z + 1, grid, m0_bricks); 

	//Material movement in every direction == momentum
	float dxl = vxl < 0 ? vxl * min(1.0f, mat) : vxl * min(1.0f, matxl);
	float dyl = vyl < 0 ? vyl * min(1.0f, mat) : vyl * min(1.0f, matyl);
	float dzl = vzl < 0 ? vzl * min(1.0f, mat) : vzl * min(1.0f, matzl);
	float dxr = vxr < 0 ? -vxr * min(1.0f, matxr) : -vxr * min(1.0f, mat);
	float dyr = vyr < 0 ? -vyr * min(1.0f, matyr) : -vyr * min(1.0f, mat);
	float dzr = vzr < 0 ? -vzr * min(1.0f, matzr) : -vzr * min(1.0f, mat);

	//update incoming matter into current cell and outgoing matter neighbour cells
	float nmat = mat + MaterialChange(x,y,z, vxl, vxr, vyl, vyr, vzl, vzr, grid, m0_bricks);
	//Apply some evaporation and set new material

	nmat = max(0.0f, nmat - EVAPORATION * timestep);
	SetData(x, y, z, nmat, grid, m_bricks);

	//Remember outgoing momentum (useful for velocity update)
	//Store temporarily in unused velocity buffers
	float om = min(0.0f, dxl) + min(0.0f, dyl) + min(0.0f, dzl)
		     + min(0.0f, dxr) + min(0.0f, dyr) + min(0.0f, dzr);
	if (vxl < 0) SetData(x, y, z, vxl * om, grid, vx_bricks);
	if (vyl < 0) SetData(x, y, z, vyl * om, grid, vy_bricks);
	if (vzl < 0) SetData(x, y, z, vzl * om, grid, vz_bricks);
	if (vxr > 0) SetData(x + 1, y, z, vxr * om, grid, vx_bricks);
	if (vyr > 0) SetData(x, y + 1, z, vyr * om, grid, vy_bricks);
	if (vzr > 0) SetData(x, y, z + 1, vzr * om, grid, vz_bricks);

	//mark brick as nonempty
	uint brickIdx = GetBrickIDX(x, y, z);
	uint brick_addr = grid[brickIdx];
	if(nmat > 0.001) brick_m[brick_addr] = 1;
}

//Retrieves amount of incoming momentum on the X-axis from tangential moving material across the y and z axis
inline float IncomingMomentumX(uint x, uint y, uint z, __global uint* grid, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* m_bricks)
{
	float yl = GetData(x, y - 1, z, grid, vx_bricks);
	float yr = GetData(x, y + 1, z, grid, vx_bricks);
	//incoming for x across y axis
	float xym = -min(0.0f, GetData(x - 1, y + 1, z, grid, vy_bricks)) * AL * GetData(x - 1, y + 1, z, grid, m_bricks) * max(0.0f, yr) * AL //left above
		+ max(0.0f, GetData(x - 1, y, z, grid, vy_bricks)) * AL * GetData(x - 1, y - 1, z, grid, m_bricks) * max(0.0f, yl) * AL//left below
		+ -min(0.0f, GetData(x, y + 1, z, grid, vy_bricks)) * AL * GetData(x, y + 1, z, grid, m_bricks) * min(0.0f, yr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vy_bricks)) * AL * GetData(x, y - 1, z, grid, m_bricks) * min(0.0f, yl) * AL; //right below
	float zl = GetData(x, y, z - 1, grid, vx_bricks);
	float zr = GetData(x, y, z + 1, grid, vx_bricks);
	//incoming for x across z axis
	float xzm = -min(0.0f, GetData(x - 1, y, z + 1, grid, vz_bricks)) * AL * GetData(x - 1, y, z + 1, grid, m_bricks) * max(0.0f, zr) * AL //left above
		+ max(0.0f, GetData(x - 1, y, z, grid, vz_bricks)) * AL * GetData(x - 1, y, z - 1, grid, m_bricks) * max(0.0f, zl) * AL//left below
		+ -min(0.0f, GetData(x, y, z + 1, grid, vz_bricks)) * AL * GetData(x, y, z + 1, grid, m_bricks) * min(0.0f, zr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vz_bricks)) * AL * GetData(x, y, z - 1, grid, m_bricks) * min(0.0f, zl) * AL; //right below
	return xym + xzm;
}

//Retrieves amount of incoming momentum on the Y-axis from tangential moving material across the x and z axis
float IncomingMomentumY(uint x, uint y, uint z, __global uint* grid, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* m_bricks)
{
	float xl = GetData(x - 1, y, z, grid, vy_bricks);
	float xr = GetData(x + 1, y, z, grid, vy_bricks);
	//incoming for x across y axis
	float yxm = -min(0.0f, GetData(x + 1, y - 1, z, grid, vx_bricks)) * AL * GetData(x + 1, y - 1, z, grid, m_bricks) * max(0.0f, xr) * AL //left above
		+ max(0.0f, GetData(x, y - 1, z, grid, vx_bricks)) * AL * GetData(x - 1, y - 1, z, grid, m_bricks) * max(0.0f, xl) * AL//left below
		+ -min(0.0f, GetData(x + 1, y, z, grid, vx_bricks)) * AL * GetData(x + 1, y, z, grid, m_bricks) * min(0.0f, xr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vx_bricks)) * AL * GetData(x - 1, y, z, grid, m_bricks) * min(0.0f, xl) * AL; //right below
	float zl = GetData(x, y, z - 1, grid, vy_bricks);
	float zr = GetData(x, y, z + 1, grid, vy_bricks);
	//incoming for x across z axis
	float yzm = -min(0.0f, GetData(x, y - 1, z + 1, grid, vz_bricks)) * AL * GetData(x, y - 1, z + 1, grid, m_bricks) * max(0.0f, zr) * AL //left above
		+ max(0.0f, GetData(x, y - 1, z, grid, vz_bricks)) * AL * GetData(x, y - 1, z - 1, grid, m_bricks) * max(0.0f, zl) * AL//left below
		+ -min(0.0f, GetData(x, y, z + 1, grid, vz_bricks)) * AL * GetData(x, y, z + 1, grid, m_bricks) * min(0.0f, zr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vz_bricks)) * AL * GetData(x, y, z - 1, grid, m_bricks) * min(0.0f, zl) * AL; //right below
	return yxm + yzm;
}

//Retrieves amount of incoming momentum on the Z-axis from tangential moving material across the x and y axis
float IncomingMomentumZ(uint x, uint y, uint z, __global uint* grid, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* m_bricks)
{
	float xl = GetData(x - 1, y, z, grid, vz_bricks);
	float xr = GetData(x + 1, y, z, grid, vz_bricks);
	//incoming for x across y axis
	float zxm = -min(0.0f, GetData(x + 1, y, z - 1, grid, vx_bricks)) * AL * GetData(x + 1, y, z - 1, grid, m_bricks) * max(0.0f, xr) * AL //left above
		+ max(0.0f, GetData(x, y, z - 1, grid, vx_bricks)) * AL * GetData(x - 1, y, z - 1, grid, m_bricks) * max(0.0f, xl) * AL//left below
		+ -min(0.0f, GetData(x + 1, y, z, grid, vx_bricks)) * AL * GetData(x + 1, y, z, grid, m_bricks) * min(0.0f, xr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vx_bricks)) * AL * GetData(x - 1, y, z, grid, m_bricks) * min(0.0f, xl) * AL; //right below
	float yl = GetData(x, y - 1, z, grid, vz_bricks);
	float yr = GetData(x, y + 1, z, grid, vz_bricks);
	//incoming for x across z axis
	float zym = -min(0.0f, GetData(x, y + 1, z - 1, grid, vy_bricks)) * AL * GetData(x, y + 1, z - 1, grid, m_bricks) * max(0.0f, yr) * AL //left above
		+ max(0.0f, GetData(x, y, z - 1, grid, vy_bricks)) * AL * GetData(x, y - 1, z - 1, grid, m_bricks) * max(0.0f, yl) * AL//left below
		+ -min(0.0f, GetData(x, y + 1, z, grid, vy_bricks)) * AL * GetData(x, y + 1, z, grid, m_bricks) * min(0.0f, yr) * AL //right above
		+ max(0.0f, GetData(x, y, z, grid, vy_bricks)) * AL * GetData(x, y - 1, z, grid, m_bricks) * min(0.0f, yl) * AL; //right below
	return zxm + zym;
}

__kernel void velocityAdvection(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* brick_m, __global float* m_bricks, __global float* m0_bricks, __global float* vx0_bricks, __global float* vy0_bricks,
                                __global float* vz0_bricks, __global float* vx_bricks, __global float* vy_bricks, __global float* vz_bricks, __global float* p0_bricks, __read_only image3d_t worldGrid, __global const unsigned short* worldBricks)
{
	int id = get_global_id(0);
    //Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	//Load velocity and mass data so we can process momentum
	float vxl = GetData(x - 1, y, z, grid, vx_bricks) * AL;
	float vyl = GetData(x, y - 1, z, grid, vy_bricks) * AL;
	float vzl = GetData(x, y, z - 1, grid, vz_bricks) * AL;
	float vxc = GetData(x, y, z, grid, vx_bricks) * AL;
	float vyc = GetData(x, y, z, grid, vy_bricks) * AL;
	float vzc = GetData(x, y, z, grid, vz_bricks) * AL;
	float vxr = GetData(x + 1, y, z, grid, vx_bricks) * AL;
	float vyr = GetData(x, y + 1, z, grid, vy_bricks) * AL;
	float vzr = GetData(x, y, z + 1, grid, vz_bricks) * AL;

	float omat = GetData(x, y, z, grid, m_bricks);
	float omatxl2 = GetData(x - 2, y, z, grid, m_bricks);
	float omatyl2 = GetData(x, y - 2, z, grid, m_bricks);
	float omatzl2 = GetData(x, y, z - 2, grid, m_bricks);
	float omatxl = GetData(x - 1, y, z, grid, m_bricks);
	float omatyl = GetData(x, y - 1, z, grid, m_bricks);
	float omatzl = GetData(x, y, z - 1, grid, m_bricks);
	float omatxr = GetData(x + 1, y, z, grid, m_bricks);
	float omatyr = GetData(x, y + 1, z, grid, m_bricks);
	float omatzr = GetData(x, y, z + 1, grid, m_bricks);

	float mat = GetData(x, y, z, grid, m0_bricks);
	float matxl = GetData(x - 1, y, z, grid, m0_bricks);
	float matyl = GetData(x, y - 1, z, grid, m0_bricks);
	float matzl = GetData(x, y, z - 1, grid, m0_bricks);
	float matxr = GetData(x + 1, y, z, grid, m0_bricks);
	float matyr = GetData(x, y + 1, z, grid, m0_bricks);
	float matzr = GetData(x, y, z + 1, grid, m0_bricks);

	float avxl = max(0.0f, vxl);
	float avxr = min(0.0f, vxr);
	float avxcl = max(0.0f, vxc);
	float avxcr = min(0.0f, vxc);
	float avyl = max(0.0f, vyl);
	float avyr = min(0.0f, vyr);
	float avycl = max(0.0f, vyc);
	float avycr = min(0.0f, vyc);
	float avzl = max(0.0f, vzl);
	float avzr = min(0.0f, vzr);
	float avzcl = max(0.0f, vzc);
	float avzcr = min(0.0f, vzc);

    //incoming colinear momentum across given axis                           
	float imx = (avxl * avxl * omatxl2) - (avxr * avxr * omatxr);
	float imy = (avyl * avyl * omatyl2) - (avyr * avyr * omatyr);
	float imz = (avzl * avzl * omatzl2) - (avzr * avzr * omatzr);

	//old momentum across axis
	float mx0 = avxcl * omatxl + avxcr * omat;
	float my0 = avycl * omatyl + avycr * omat;
	float mz0 = avzcl * omatzl + avzcr * omat;

	//outgoing momentum, stored temporarily during material advection step
	float omx = GetData(x,y,z, grid, vx0_bricks);
	float omy = GetData(x, y, z, grid, vy0_bricks);
	float omz = GetData(x, y, z, grid, vz0_bricks);

	//Remaining momentum
	float rmx = mx0 + omx;
	float rmy = my0 + omy;
	float rmz = mz0 + omz;

	//New momentum = remainin momentum + incoming colinear momentum + incoming tangential momentum
	float vcx = rmx + imx + IncomingMomentumX(x, y, z, grid, vx_bricks, vy_bricks, vz_bricks, m_bricks);
	float vcy = rmy + imy + IncomingMomentumY(x, y, z, grid, vx_bricks, vy_bricks, vz_bricks, m_bricks);
	float vcz = rmz + imz + IncomingMomentumZ(x, y, z, grid, vx_bricks, vy_bricks, vz_bricks, m_bricks);

	//mass of source cell
	float massx = vcx > 0 ? matxl : mat;
	float massy = vcy > 0 ? matyl : mat;
	float massz = vcz > 0 ? matzl : mat;

	//New velocity *
	float nvcx = massx == 0 ? 0 : vcx / massx * INVAL;
	float nvcy = massy == 0 ? 0 : vcy / massy * INVAL;
	float nvcz = massz == 0 ? 0 : vcz / massz * INVAL;

	//Add global acceleration
	//for (int f = 0; f < ga.size(); f++)
	//{
		nvcx += timestep * 0.0f;//ga[f].x;
		nvcy += timestep * -9.81f * CELLSIZE;// ga[f].y;
		nvcz += timestep * 0.0f; //ga[f].z;
	//}

	//Check if not involving static cell, then finalise a valid velocity by clamping and dampening
	bool staticc = IsCellStatic(x,y,z, grid, brick_static, m0_bricks, worldGrid, worldBricks);
	bool staticx = staticc || IsCellStatic(x - 1, y, z, grid, brick_static, m0_bricks, worldGrid, worldBricks);
	bool staticy = staticc || IsCellStatic(x, y - 1, z, grid, brick_static, m0_bricks, worldGrid, worldBricks);
	bool staticz = staticc || IsCellStatic(x, y, z - 1, grid, brick_static, m0_bricks, worldGrid, worldBricks);

	float nvx = !staticx * nvcx;
	float nvy = !staticy * nvcy;
	float nvz = !staticz * nvcz;
	SetData(x, y, z, nvx, grid, vx0_bricks);
	SetData(x, y, z, nvy, grid, vy0_bricks);
	SetData(x, y, z, nvz, grid, vz0_bricks);
}

		//float4 f = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
		//uchar4 uc = (uchar4)(0xFA, 0xFB, 0xFC, 0xFD);

		//printf("f4 = %2.2v4hlf\n", f);
		//printf("uc = %#v4hhx\n", uc);

//For now just run for every allocated brick, using brick jobs can be reduced to just running for bricks that actually need updating
//However cost is very low, so not a priority, also runs jobs for every cell if individual brick data needs to be set.
__kernel void brickUpdate(__global uint* grid, __global uint* brick_x, __global uint* brick_y, __global uint* brick_z, __global uint* brick_a, __global uint* brick_oa, __global uint* brick_jobs, __global float* brick_m, __global char* brick_static, __global float* m0_bricks, __global float* vx0_bricks, __global float* vy0_bricks, __global float* vz0_bricks)
{
	int id = get_global_id(0);
	uint brick_id = id / CAPE_BRICKSIZE;
	char s = brick_static[brick_id];
	uint j = brick_jobs[brick_id];
	uint brick_addr = brick_a[brick_id];

	//Reset default values for the upcoming update (for any brick)
	brick_m[brick_id] = 0;

	//inverse mapping to bx by and bz
	const uint bx = brick_addr % (CAPE_GRIDWIDTH); 
	const uint by = (brick_addr / CAPE_GRIDWIDTH) % (CAPE_GRIDHEIGHT);
	const uint bz = brick_addr / (CAPE_GRIDWIDTH * CAPE_GRIDHEIGHT);

	if(j == UINT32_MAX) return; //nothing to do here.

	brick_x[brick_id] = bx;
	brick_y[brick_id] = by;
	brick_z[brick_id] = bz;

	if(j == 0) //brick has been freed, make it static, clear values
	{ 
		grid[brick_addr] = UINT32_MAX;
		m0_bricks[id] = 0; //Clear brick cells of remaining small mass
		brick_x[brick_id] = UINT32_MAX;
		brick_static[brick_id] = true;
	} 
	else if(j == 1) //freed brick is recycled, assume it may have not been previously freed (freed and recycled in same update)
	{	
		uint oa = brick_oa[brick_id];
		grid[oa] = UINT32_MAX;
		m0_bricks[id] = 0; //Clear brick cells of remaining small mass
		brick_static[brick_id] = (bx == 0 || bx >= CAPE_GRIDWIDTH || by == 0 || by >= CAPE_GRIDHEIGHT || bz == 0 || bz >= CAPE_GRIDDEPTH);
		grid[brick_addr] = brick_id;
		vx0_bricks[id] = 0;
		vy0_bricks[id] = 0;
		vz0_bricks[id] = 0;

		//Reset any values in possibly existing neighbouring bricks
		//Work this into adjusted enqueue  --inverse neighbour mapping a good performance booster?
		uint bxo = bx * CAPE_BRICKDIM;
		uint byo = by * CAPE_BRICKDIM;
		uint bzo = bz * CAPE_BRICKDIM;
		for(int y = 0; y < CAPE_BRICKDIM; y++)
			for(int z = 0; z < CAPE_BRICKDIM; z++)
			{
				SetData((bx+1) * CAPE_BRICKDIM, byo + y, bzo + z, 0, grid, vx0_bricks);
				SetData((bx+1) * CAPE_BRICKDIM, byo + y, bzo + z, 0, grid, vy0_bricks);
				SetData((bx+1) * CAPE_BRICKDIM, byo + y, bzo + z, 0, grid, vz0_bricks);
			}

		for(int x = 0; x < CAPE_BRICKDIM; x++)
			for(int z = 0; z < CAPE_BRICKDIM; z++)
			{
				SetData(bxo + x,(by+1) * CAPE_BRICKDIM, bzo + z, 0, grid, vx0_bricks);
				SetData(bxo + x,(by+1) * CAPE_BRICKDIM, bzo + z, 0, grid, vy0_bricks);
				SetData(bxo + x,(by+1) * CAPE_BRICKDIM, bzo + z, 0, grid, vz0_bricks);
			}

		for(int x = 0; x < CAPE_BRICKDIM; x++)
			for(int y = 0; y < CAPE_BRICKDIM; y++)
			{
				SetData(bxo + x, byo + y, (bz+1) * CAPE_BRICKDIM, 0, grid, vx0_bricks);
				SetData(bxo + x, byo + y, (bz+1) * CAPE_BRICKDIM, 0, grid, vy0_bricks);
				SetData(bxo + x, byo + y, (bz+1) * CAPE_BRICKDIM, 0, grid, vz0_bricks);
			}
	} 
	if (j == 2)//a new brick allocated and initialised at end of list
	{	
		brick_static[brick_id] = (bx == 0 || bx >= CAPE_GRIDWIDTH || by == 0 || by >= CAPE_GRIDHEIGHT || bz == 0 || bz >= CAPE_GRIDDEPTH);
		grid[brick_addr] = brick_id;
	}
}

//Converts rgb value to the 4-4-4 12 bit rgb format used 
inline uint LerpToRGB(float r, float g, float b)
{
	r = clamp(r, 0.0f, 1.0f);
	g = clamp(g, 0.0f, 1.0f);
	b = clamp(b, 0.0f, 1.0f);
	return (uint)(15 * b) + ((uint)(15 * g) << 4) + ((uint)(15 * r) << 8);
}

__kernel void worldSetter(__global uint* grid, __global uint* bx, __global uint* by, __global uint* bz, __global bool* brick_static, __global float* m0_bricks, __write_only image3d_t worldGrid, __global const unsigned short* worldBricks, __global uint* zeroes)
{
	int id = get_global_id(0);

	//Get brick location
	const uint bidx = id / CAPE_BRICKSIZE;
	const uint bxv = bx[bidx];
	const uint byv = by[bidx];
	const uint bzv = bz[bidx];
	if(brick_static[bidx]) return;

	//inverse mapping to x y and z inside brick
	const uint ib = id - bidx * CAPE_BRICKSIZE;
	const uint lx = ib & (CAPE_BRICKDIM - 1); 
	const uint ly = (ib / CAPE_BRICKDIM) & (CAPE_BRICKDIM - 1);
	const uint lz = ib / (CAPE_BRICKDIM * CAPE_BRICKDIM);

	//global x y z
	const uint x = bxv * CAPE_BRICKDIM + lx;
	const uint y = byv * CAPE_BRICKDIM + ly;
	const uint z = bzv * CAPE_BRICKDIM + lz;

	uint color = 0;
	float mass = GetData(x,y,z, grid, m0_bricks);
	if (mass > 0.0001f)
	{
		//interpolate mass between 0 and - max mass for the 15 different colors.
		float diffFromEmpty = 1 - clamp(1 - mass, 0.0f, 1.0f);
		if (diffFromEmpty < MINRENDERMASS)
			worldSet(x - CAPE_BRICKDIM,y - CAPE_BRICKDIM,z - CAPE_BRICKDIM, worldGrid, worldBricks, zeroes, 0);
		else
		{
			float b = 1 - diffFromEmpty / 2.0f + 0.5f;
			float g = diffFromEmpty > 0.5f ? 1 - (diffFromEmpty - 0.5f) : 1;
			worldSet(x - CAPE_BRICKDIM,y - CAPE_BRICKDIM,z - CAPE_BRICKDIM, worldGrid, worldBricks, zeroes, LerpToRGB(0, g, b));
		}	
	}
}


 